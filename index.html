<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>ECMAScript Workshop</h1>
				</section>

				<section>
					<h2>Today</h2>
					<ul>
						<li>Modules</li>
						<li>Classes</li>
						<li>Iterator & iterable</li>
						<li>Arrow functions</li>
						<li>Destructuring</li>
						<li>Generators</li>
						<li>Template strings</li>
						<li>Maps/Sets</li>
					</ul>
				</section>

				<section>
					<section>
						<h1>Modules</h1>
					</section>
					<section>
						<h2>Benefits</h2>
						<p>
							No more global namespace pollution.
						</p>
					</section>

					<section>
						<h2>Defaults</h2>
						<p>There is exactly one module per file and one file per module.</p>
						<p>By default anything you declare in a file is not available outside that file (awesome).</p>
					</section>

					<section>
						<h2>Named exports</h2>
						<p>A module can export multiple things by prefixing its declarations with the keyword export:</p>
						<pre><code class="hljs" data-trim contenteditable>
export var myVar1 = ...;
export let myVar2 = ...;
export const MY_CONST = ...;
export function myFunc() {}
export class MyClass {}
					</code></pre>
						<p>These exports are distinguished by their names and are called named exports.</p>
					<pre><code class="hljs" data-trim contenteditable>
import { myFunc, myVar1 } from 'lib';
myFunc();
					</code></pre>
					</section>

					<section>
						<h2>Named exports</h2>
						<p>You can also list everything you want to export at the end of the module (which is once again similar in style to the revealing module pattern):</p>
						<pre><code class="hljs" data-trim contenteditable>
const MY_CONST = ...;
function myFunc() {}
export { MY_CONST, myFunc };
					</code></pre>
					</section>

					<section>
						<h2>import the whole module</h2>
						<p>You can also import the complete module using a wildcard:</p>
						<pre><code class="hljs" data-trim contenteditable>
import * as lib from 'lib';
lib.myFunc();
					</code></pre>
					</section>

					<section>
						<h2>Single default export</h2>
						<p>If you want to export a single value from the module then you can use default export. </p>
						<p>For example, a class:</p>
						<pre><code class="hljs" data-trim contenteditable>
export default class {}
					</code></pre>
						<p>And import like this (omit the curly braces):</p>
						<pre><code class="hljs" data-trim contenteditable>
import MyClass from 'MyClass';
var instance = new MyClass();
					</code></pre>
					</section>

					<section>
						<h2>Mixture</h2>
						<p>Module can have both named exports and a default export.</p>
						<p>In such cases, to import a module's default export, you have to omit the curly braces in the import statement:</p>
						<pre><code class="hljs" data-trim contenteditable>
import myDefault, { foo, bar } from 'lib';
					</code></pre>
					</section>

					<section>
						<h2>Best practise?</h2>
						<p> Only use <b>export default</b>, and to do that at the end of your module files. Like this:</p>
						<pre><code class="hljs" data-trim contenteditable>
var api = {
  foo: 'bar',
  baz: 'ponyfoo'
}
export default api
					</code></pre>
						<p>Easy then to import the whole thing like this:</p>
						<pre><code class="hljs" data-trim contenteditable>
import api from 'api';
api.foo; // bar
					</code></pre>
					</section>

					<section>
					<h2>Code task 1 - export two named functions</h2>
						<p>In `src/00-modules/named.js´ create and export two named functions:</p>
						<ul>
							<li>
								sum(x,y) - A function that add two numbers
							</li>
							<li>
								multiply(x,y) - A function that multiply two numbers
							</li>
						</ul>
					</section>

					<section>
					<h2>Code task 2 - export two functions by default</h2>
						<p>In `src/00-modules/default.js` import the two functions created in the previous task, then export them again, but as a single default export. </p>
					</section>

					<section>
						<h2>Export Syntax</h2>
						<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export</a>
					</section>

					<section>
						<h2>Import Syntax</h2>
						<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import</a>
					</section>

				</section>

				<section>
					<section>
						<h1>Classes</h1>
					</section>
					<section>
						<h2>Benefits</h2>
						<p>
							Simpler and clearer syntax to create objects and to deal with inheritance
						</p>
					</section>
					<section>
						<h2>Syntatical sugar</h2>
						<p>Classes aren't really 'classes', instead they are functions which are in turn objects</p>
						<p>It’s important to understand that while JavaScript is an object-oriented language, it is prototype-based and does not implement a traditional class system.</p>
					</section>

					<section>
						<h2>JavaScript Objects</h2>
						<p>
							Almost everything in JavaScript are objects (including functions and arrays). Except for primitives:
						</p>
						<ul>
							<li>
								numbers
							</li>
							<li>
								boolean
							</li>
							<li>
								strings
							</li>
							<li>
								undefined
							</li>
							<li>
								null
							</li>
						</ul>
					</section>
					<section>
						<h2>JavaScript Objects</h2>
						<p>
							An object is a collection of properties, and a property is an association between a name (or key) and a value.
							A property's value can be a function, in which case the property is known as a method.
					</section>
					<section>
						<h2>Creating A JavaScript Object</h2>
					<pre><code class="hljs" data-trim contenteditable>
// The easiest way to create an object is like this:
let myObject = { 'key1': "Awesome", 'key2': "Object" }

// Or:
var myObject = Object.create(new Object());
myObject.key1 = "Awesome";
myObject.key2 = "Object";

// Or:
function MyObject(value1, value2) {
  this.key1 = value1;
  this.key2 = value2;
}
var myObject = new MyObject("Awesome", "Object");
					</code></pre>
						<p>Which of these alternatives are suited to create multiple instances of same type?</p>
					</section>

					<section>
						<h2>Using A JavaScript Object</h2>
					<pre><code class="hljs" data-trim contenteditable>
// Get a property
var value = myObject.key1;
var value = myObject["key1"];

// Set a property
myObject.property = "Value";
myObject["property with space in it"] = "Value";

// Call a method
myObject.toString();

// To find out if a property exists on an object
'key1' in myObject; // true
					</code></pre>
					</section>

					<section>
					<h2>Classes in ECMAScript 5</h2>
					<pre><code class="hljs" data-trim contenteditable>
function MyClass (id) {
     var privateField = "My secret";
     // Instance property
     this.id = id;
}

// Instance method
MyClass.prototype.myMethod = function () {};

var instance1 = new MyClass(1);
var instance2 = new MyClass(2);
instance1.myMethod();
instance1.id; // 1
instance2.myMethod();
instance2.id; // 2
instance1 instanceof MyClass; // true
					</code></pre>
						<p>Prototype methods are shared across all instances of the class. One method, many instances!</p>
					</section>

					<section>
					<h2>Why is MyClass a function, shouldn’t it be a class?</h2>
					<p>
						MyClass is a constructor function, and combined with the new keyword, work together to create new objects in much in the same way classes do in other OO languages.
					</p>
					<p>When you create an object using the new keyword, it creates a new object, passes it in as this to the constructor function.</p>
					</section>

					<section>
						<h2>Inherited properties and own properties</h2>
						<p>The own properties are properties that were defined on the instance,
							while the inherited properties were inherited from the Function’s Prototype object.</p>
					</section>

					<section>
					<h2>Functions have a prototype</h2>
					<p>When you define a function within JavaScript, it comes with a few pre-defined properties and one of these is the illusive prototype.</p>
					<p>
						(1) Initially an empty object. (2) You can add methods and properties on a function’s prototype property
to make those methods and properties <b>available</b> to instances of that function. All class instances, past and future, will be affected.
					</p>
				    </section>

					<section>
						<h2>Prototypal inheritance</h2>
						<!--<p>In classical languages, like Java, instances are created from classes.
							JavaScript differs in that it has prototypal inheritance, in which there are no classes.
							Instead, objects inherit from other objects.
							</p>-->
						<p>Objects inherit from other objects.</p>
					</section>

					<section>
						<h2>How does prototype inheritance work?</h2>
						<p>
							Every object in JavaScript has a special related object called the prototype.
						</p>
						<pre><code class="hljs" data-trim contenteditable>
vehicle.__proto__ = machine
// machine is the prototype of vehicle

car.__proto__ = vehicle
// vehicle is the prototype of car
					</code></pre>
						<p>This is a prototype chain: car -> vehicle -> machine</p>
						<p>
							When looking up a property, Javascript will try to find the property in the object itself. If it does not find it then it tries in it's prototype, and so on.
						</p>
					</section>

					<!--<section>
						<h2>Functions vs objects prototype</h2>
						<p>An object’s prototype is the object from which it is inheriting properties. </p>
						<p>A function’s prototype is used as the object to be assigned as the prototype for new objects’ created using this function as a constructor function.</p>
					</section>

					<section>
						<h2>Inherited properties vs. native properties</h2>
					<pre><code class="hljs" data-trim contenteditable>
instance1.__proto__; // { myMethod: [Function] }
instance1.hasOwnProperty("id"); // true
instance1.hasOwnProperty("myMethod"); // false
					</code></pre>
					</section>

					<section>
						<h2>Described by Douglas Crockford</h2>
						<blockquote>
							you make prototype objects, and then … make new instances. Objects are mutable in JavaScript, so we can augment the new instances, giving them new fields and methods. These can then act as prototypes for even newer objects. We don't need classes to make lots of similar objects… Objects inherit from objects. What could be more object oriented than that?
						</blockquote>
					</section>-->


					<section>
					<h2>Subclasses in ECMAScript 5</h2>
					<pre><code class="hljs" data-trim contenteditable>
function MySubClass(id) {
  MyClass.call(this, id);
}

// Inherit from the parent class
MySubClass.prototype = Object.create(MyClass.prototype);
MySubClass.prototype.constructor = MySubClass;

// Child class method
MySubClass.prototype.myMethod = function() {
  MyClass.prototype.method.call(this);
}
					</code></pre>
						<p>Easy to read?</p>
					</section>

					<section>
					<h2>Classes in ECMAScript 6</h2>
					<pre><code class="hljs" data-trim contenteditable>
class MyClass {
    constructor (id) {
        this.id = id
    }
    myMethod () {}
    static myStaticMethod() {}
}
let instance = new MyClass(1);
instance instanceof MyClass; // true
typeof MyClass // 'function' (old-school constructor function)
MyClass.myStaticMethod();
darth.hasOwnProperty("myMethod")
MyClass.prototype.myMethod(); // prototype-based
					</code></pre>
						<p>The class keyword is syntactical sugar, JavaScript remaining prototype-based!</p>
						<p>This is the prototype chain: MyClass -> Object</p>
					</section>

					<section>
					<h2>Subclasses in ECMAScript 6</h2>
					<pre><code class="hljs" data-trim contenteditable>
class MySubClass extends MyClass {
    constructor (id) {
        super(id)
    }
}
					</code></pre>
						<p>This is the prototype chain: MySubClass -> MyClass -> Object</p>
					</section>

					<section>
					<h2>Code task 3 - Create a class</h2>
						<p>Create a class equal to the ECMAScript 5 code:</p>
					<pre><code class="hljs" data-trim contenteditable>
function Point(x,y) {
    this.x = x;
    this.y = y;
}
// Static method
Point.distance = function (a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
};
Point.prototype.toString = function () {
    return this.x + ' ' + this.y;
};
module.exports = Point;
					</code></pre>
					</section>

					<section>
					<h2>Code task 4 - Class inheritance</h2>
						<p>Extend the Point class from previous task so that it behaves equal to the ECMAScript 5 code below:</p>
					<pre><code class="hljs" data-trim contenteditable>
// Child class constructor
var ColorPoint = function (x, y, color) {
    Point.call(this, x, y);
    this.color = color || 'red';
};

// Inherit from the parent class
ColorPoint.prototype = Object.create(Point.prototype);
ColorPoint.prototype.constructor = ColorPoint;

// Child class method
ColorPoint.prototype.getColor = function () {
    return this.color;
};
module.exports = ColorPoint;
					</code></pre>
					</section>

					<section>
					<h2>References</h2>
						<ul>
							<li><a href="http://www.objectplayground.com">http://www.objectplayground.com</a></li>
							<li><a href="http://blog.pluralsight.com/understanding-javascript-objects-2">http://blog.pluralsight.com/understanding-javascript-objects-2</a></li>
							<li><a href="http://blog.pluralsight.com/understanding-javascript-prototypes">http://blog.pluralsight.com/understanding-javascript-prototypes</a> </li>
							<li><a href="http://aaditmshah.github.io/why-prototypal-inheritance-matters">http://aaditmshah.github.io/why-prototypal-inheritance-matters</a></li>
							<li><a href="https://blog.pivotal.io/labs/labs/javascript-constructors-prototypes-and-the-new-keyword">https://blog.pivotal.io/labs/labs/javascript-constructors-prototypes-and-the-new-keyword</a></li>
							<li><a href="https://www.nczonline.net/blog/2012/10/16/does-javascript-need-classes">https://www.nczonline.net/blog/2012/10/16/does-javascript-need-classes</a></li>
							<li><a href="http://exploringjs.com/es6/ch_classes.html">http://exploringjs.com/es6/ch_classes.html</a></li>
							<li><a href="https://www.reinteractive.net/posts/235-es6-classes-and-javascript-prototypes">https://www.reinteractive.net/posts/235-es6-classes-and-javascript-prototypes</a></li>
						</ul>
					</section>

				</section>

				<section>
					<section>
						<h1>Iterator & iterable</h1>
					</section>

					<section>
						<h2>for-of-loop</h2>
						<p>ES6 has a new loop — for-of. It works with iterables. Let’s look at his signature:</p>
						<pre><code class="hljs" data-trim contenteditable>
for (let item of ITERABLE) {
  CODE BLOCK
}
					</code></pre>
						<p>
							It’s similar to for-in loop, which can be used to iterate through object properties.
						</p>
					</section>

					<section>
						<h2>Iterable</h2>
						<p>
							Iterable is an object which has [Symbol.iterator]() method inside.
						</p>
						<p>
							The [Symbol.iterator] method must return an iterator object,
							which is actually responsible for the iteration logic.
						</p>
					</section>

					<section>
						<h2>Iterator</h2>
						<p>
							An iterator is an object with a next method that returns { done, value } tuples.
						</p>
					</section>

					<section>
						<h2>Arrays are iterable by default</h2>
						<p>We finally can use for-of for looping over the elements:</p>
						<pre><code class="hljs" data-trim contenteditable>
const arr = [1, 2, 3, 4, 5];
for (let item of arr) {
  console.log(item); // 1
                     // 2
                     // 3
                     // 4
                     // 5
}
					</code></pre>
					</section>

					<section>
						<h2>Symbol</h2>
						<p>
							Symbol is in turn an unique and immutable data type which can be used
							as an identifier for object properties — no equivalent in ES5.
						</p>
					</section>

					<section>
						<h2>Symbol</h2>
						<pre><code class="hljs" data-trim contenteditable>
// Symbol
let s1 = Symbol('abc');
let s2 = Symbol('abc');
console.log(s1 !== s2); // true
console.log(typeof s1); // 'symbol'
let obj = {};
obj[s1] = 'abc';
console.log(obj); // Object { Symbol(abc): 'abc' }
					</code></pre>
					</section>

					<section>
						<h2>Symbol.iterator</h2>
						<p>The Symbol.iterator well-known symbol specifies the default iterator for an object.</p>
					</section>

					<section>
						<h2>Encapsulating collections</h2>
						<pre><code class="hljs" data-trim contenteditable>
class Classroom {
    constructor() {
        this.students = ["Tim", "Joy", "Sue"];
    }
}
					</code></pre>
						<p>Option 1: Return a reference to the  array, in which case the caller might change the array by adding or removing items.</p>
						<p>Option 2: Another option is to make a copy of the array. Then, the original student array remains safe. However, copy operations can be expensive.</p>
						<p>Option 3: Make the classroom iterable by adding a [Symbol.iterator]() method.</p>
					</section>

					<section>
					<pre><code class="hljs" data-trim contenteditable>
function PointCloud(list) {
    this.collection = list;
}
PointCloud.prototype[Symbol.iterator] = function() {
    var index = 0;
    var array = this.collection;
    return {
        next: () => {
            var result = { value: undefined, done: true };
            if (index < array.length) {
                result.value = array[index++];
                result.done = false;
            }
            return result;
        }
    };
};
module.exports = PointCloud;
					</code></pre>
					</section>

					<section>
						<h2>References</h2>
						<ul>
							<li>
								https://medium.com/ecmascript-2015/es6-iterators-4afec026f70a#.6wfbn4xnc
							</li>
							<li>
								http://jsrocks.org/2015/09/javascript-iterables-and-iterators/
							</li>
							<li>
								http://odetocode.com/blogs/scott/archive/2015/02/09/creating-iterables-in-ecmascript-6.aspx
							</li>
						</ul>
					</section>

				</section>

				<section>
					<section>
						<h1>Arrow functions</h1>
						<p>() => {}</p>
					</section>
					<section>
						<h2>Benefits</h2>
						<ul>
							<li>
								function(){...} can now be written as () => {...}
								<ul>
									<li>Shorter syntax than using traditional anonymous functions</li>
								</ul>
							</li>
							<li>Lexically binds the <i>this</i> value
								<ul>
									<li>Which is where arrow functions shine</li>
								</ul>
							</li>
						</ul>
					</section>
					<section>
						<p>
							A quick overview of the syntax:
						</p>
						<pre>
							<code class="hjls" data-trim contenteditable>
// Basic syntax:
(param1, param2, paramN) => { statements }
(param1, param2, paramN) => expression
// equivalent to:  => { return expression; }

// Parentheses are optional when there's only one argument:
(singleParam) => { statements }
singleParam => { statements }

// A function with no arguments requires parentheses:
() => { statements }
							</code>
						</pre>
					</section>
					<section>
						<p>
							Another example:
						</p>
						<pre>
							<code class="hjls" data-trim contenteditable>
function(x) { return x+1;}

x => x+1;
							</code>
						</pre>
					</section>
					<section>
						<p>
							Here a2 is using traditional anonymous functions while a3 is using the arrow function syntax.
						</p>
						<pre>
							<code class="hjls" data-trim contenteditable>
var a = ["Hydrogen", "Helium", "Lithium", "Beryl­lium"];

var a2 = a.map(function(s){ return s.length });
var a3 = a.map( s => s.length );

//a2 = [8, 6, 7, 10]
//a3 = [8, 6, 7, 10]
							</code>
						</pre>
					</section>
					<section>
						<h2>Lexically binding this</h2>
						<p><p>
						<ul>
							<li>
								Javascript uses lexical scope
								<ul>
									<li>Like Python, Java ..</li>
								</ul>
							</li>
							<li>Block scope: let (pre ECMAScript 2015)</li>
						</ul>
						<pre>
							<code class="hjls" data-trim contenteditable>
function foo(a) {
	var b = a * 2;

	function bar(c) {
		console.log( a, b, c );
	}
	bar(b * 3);
}

foo( 2 ); // 2 4 12
							</code>
						</pre>
					</section>
					<section>
						<ul>
							<li>Every new function defines a new this. </li>
							<li>
								Object methods gets the context of the object.
								<pre>
									<code class="hjls" data-trim contenteditable>
function person(firstName, lastName, age, eyeColor) {
	this.firstName = firstName;
	this.lastName = lastName;
	this.changeName = function (name) {
    	this.lastName = name;
    };
}
									</code>
								</pre>
							</li>
						</ul>
					</section>
					<section>
						<ul>
							<li>
								When calling a function (not an object method) the this of the object is not reachable.
							</li>
							<pre>
								<code class="hjls" data-trim contenteditable>
function Person() {
	// The Person() constructor defines `this` as an instance of itself.
	this.age = 0;

	setInterval(function growUp() {
		// In nonstrict mode, the growUp() function defines `this`
		// as the global object, which is different from the `this`
		// defined by the Person() constructor.
		this.age++;
	}, 1000);
}
var p = new Person();
								</code>
							</pre>
						</ul>
					</section>
					<section>
						<p>
							That can be solved like this:
						</p>
						<pre>
							<code class="hjls" data-trim contenteditable>
function Person() {
	var self = this;
	// Some choose `that` instead of `self`.
	// Choose one and be consistent.
 	self.age = 0;

	setInterval(function growUp() {
		// The callback refers to the `self` variable of which
		// the value is the expected object.
		self.age++;
	}, 1000);
}
var p = new Person()
							</code>
						</pre>
					</section>
					<section>
						<p>
							With arrow functions and lexical binding of <i>this</i>, the problem can be solved like this:
						</p>
						<pre>
							<code class="hjls" data-trim contenteditable>
function Person(){
	this.age = 0;

	setInterval(() => {
		this.age++; // |this| properly refers to the person object
	}, 1000);
}
							</code>
						</pre>
					</section>

					<section>
						<h2>References</h2>
						<ul>
							<li><a href="http://spin.atomicobject.com/2014/10/20/javascript-scope-closures/">Javascript scope</a></li>
							<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow functions</a></li>
						</ul>
					</section>

				</section>

				<section>
					<section>
						<h1>Destructuring</h1>
						<p>
							let {a,b} = obj;
						</p>
					</section>
					<section>
						<h2>Array destructing</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
let foo = ["one", "two", "three"];

// without destructuring
let one   = foo[0];
let two   = foo[1];
let three = foo[2];

// with destructuring
let [one, two, three] = foo;
							</code>
						</pre>
					</section>
					<section>
						<h2>Object destructuring</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
let o = {p: 42, q: true};
let {p, q} = o;
							</code>
						</pre>
						<p>It is also possible to give the new variable a new name by using:</p>
						<pre>
							<code class="hjls" data-trim contenteditable>
								let {p:age, q}
							</code>
						</pre>
					</section>
					<section>
						<h2>Object destructuring</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
var metadata = {
	title: "Scratchpad",
	translations: [
		{
			locale: "de",
			localization_tags: [ ],
			last_edit: "2014-04-14T08:43:37",
			url: "/de/docs/Tools/Scratchpad",
			title: "JavaScript-Umgebung"
		}
	],
	url: "/en-US/docs/Tools/Scratchpad"
};

let { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;
							</code>
						</pre>
					</section>
					<section>
						<h2>What else?</h2>
						It is also possible to:
						<ul>
							<li>
								Swap variables:
								<pre>
									<code class="hjls" data-trim contenteditable>
										[a, b] = [b, a];
									</code>
								</pre>
							</li>
							<li>
								Ignore returned values:
								<pre>
									<code class="hjls" data-trim contenteditable>
										var [a, , b] = f();
									</code>
								</pre>
							</li>
							<li>
								Use destructuring in loops
								<pre>
									<code class="hjls" data-trim contenteditable>
										for (var {name: n, family: { father: f } } of people) {...}
									</code>
								</pre>
							</li>
						</ul>
					</section>
					<section>
						<h2>References</h2>
						<ul>
							<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring assignment</a></li>
						</ul>
					</section>
				</section>


				<section>
					<section>
						<h1>Generators</h1>
					</section>
					<section>
						<h2>What?</h2>
						<ul>
							<li>function*, yield, yield*</li>
							<li>Looks like normal function + keywords</li>
							<li>Is a type of iterator</li>
						</ul>
					</section>
					<section>
						<h2>Gang of Three</h2>
						<ul>
							<li>Iterators</li>
							<li>Observers</li>
							<li>Co-routines</li>
						</ul>
					</section>
					<section>
						<h2>Iterators</h2>
						<ul>
							<li>yield data;</li>
							<li>Iterable (for let v of vals)</li>
							<li>No initialization</li>
							<li><pre><code class="hljs" data-trim contenteditable>
var help = function* helpiterable() {
    yield 100;
}

function* myiterable() {
    while(true) {   
        yield 1;
        yield 2;
        for(var i=0;i<10;i++) {
            yield i*2;
        }
        yield* [1,2,3];
        yield* help();
        yield; // yield undefined;
    }
    return 0;
    // if return is not added, then it is implicit as return undefined;
}

							</code></pre></li>
						</ul>
						
					</section>
					<section>
						<h2>Observers</h2>
						<ul>
							<li>var data = yield;</li>
							<li>var data = (yield)++;</li>
							<li>Requires initialization (to start observer)</li>
							<li>Pauses until input is received</li>
							<li>Can wrap to avoid explicit initialization</li>
							<li><pre><code class="hljs" data-trim contenteditable>
function* myobserver() {
    console.log(yield);
}

var miobserver = myobserver();
miobserver.next(); // initialize
miobserver.next("test"); // writes "test" to console

							</code></pre></li>
						</ul>
						
					</section>
					<section>
						<h2>Co-routines</h2>
						<ul>
							<li>Produces AND consumes data</li>
							<li>Complex</li>
							<li>Avoid unless absolutely needed</li>
							<li><pre><code class="hljs" data-trim contenteditable>
function* mycoroutine() {
    yield 1; // A
    console.log(yield); // B
    console.log(yield); // C
}

var micoroutine = mycoroutine();
var i = micoroutine.next(); // initialize // A, and pauses at A
micoroutine.next(); // goes to B, and pauses, waits for data
micoroutine.next("test"); // writes "test" to console and continues until next yield, pauses // B->C
micoroutine.next("test2"); // writes "test" to console goes to invisible return // B->C
console.log(micoroutine.next()); // returns "undefined" from return undefined; exits generator

							</code></pre></li>
						</ul>
						
					</section>
					<section>
						<h2>Why? Usage!</h2>
						<ul>
							<li>As iterator</li>							
							<li>Lazy evaluation</li>
							<li>Less memory consumption</li>
							<li>Less latency</li>
							<li>Avoid callback-hell</li>
							<li>More fluent (synchronized)</li>
							<li>Chain generators UNIX way</li>
							<li>Infinite collection</li>
					</ul>
					</section>
					<section>
						<h2>Finally</h2>
						<ul>
							<li>yield pauses/suspends the generator</li>
							<li>next() or next(data) to resume</li>
							<li>Generator continues from exactly where it paused</li>
							<li>yield resumes execution until explicit or implicit yield, return, throw</li>
							<li>Generator is initially suspended at start of its body</li>
							<li><pre><code class="hljs" data-trim contenteditable>
function* producer() {
        console.log('1');
        yield; // (A)
        console.log('2'); // (B)
    }
let myProducer = producer(); // nothing happens, generator object is returned
myProducer.next(); // will pause on yield on (A)
myProducer.next(); // will continue, and execute (B). Generator is done.

							</code></pre></li>
						</ul>
					</section>
					<section>
						<h2>Tips</h2>
						<ul>
							<li>Usually loops within generator to continue "infinitely"</li>
							<li>No return = implicit return undefined</li>
							<li>Return value is ignored when used as iterable</li>
							<li>yield yields an object with properties value and done</li>
							<li>Recursive call with yield*</li>
							<li>Not possible to yield inside callback</li>
						</ul>
					</section>
					<section>
						<h2>Resources</h2>
						<ul>
							<li>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/</li>
							<li>Look for: iterator, generator, function*, yield, yield*</li>
							<li>http://www.2ality.com/2015/03/es6-generators.html</li>
							<li>http://gajus.com/blog/2/the-definitive-guide-to-the-javascript-generators</li>
							<li>http://tobyho.com/2013/06/16/what-are-generators/</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h1>Template strings</h1>
						<p>
							`Unleash the power of backticks`
                        </p>
					</section>
					<section>
						<h2>Embedded expressions</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
// The good oldfashioned way
var a = 5;
var b = 10;
console.log('The sum of ' + a + ' and ' + b + ' is ' + (a + b));

// With template strings
console.log(`The sum of ${a} and ${b} is ${a + b}`);
							</code>
						</pre>
					</section>
					<section>
						<h2>Multi-line</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
// The good oldfashioned way
console.log('Thank you Mario!\n' + 
    'But our princess is in another castle.');

// With template strings
console.log(`Thank you Mario!
But our princess is in another castle.`);
							</code>
						</pre>
					</section>
					<section>
						<h2>Tagged template strings</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
var a = 5;
var b = 10;

function tag(strings, value1, value2) {
    console.log(strings[0]); // 'Hello '
    console.log(strings[1]); // ' world '
    console.log(value1);     // 15
    console.log(value2);     // 50

    return 'Foo!';
}

tag`Hello ${ a + b } world ${ a * b }`;
// 'Foo!'
							</code>
						</pre>
					</section>
					<section>
						<h2>References</h2>
                        <li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/template_strings">Template Strings on Mozilla Developer Network</a></li>
                    </section>
					<section>
                        <h2>Code tasks</h2>
                        <h3>1. Variable substitution</h3>
						<p>
                            In `src/04-template-strings/01-variable-substitution.js´ change 
                            the log() method to use embedded expressions instead of concatenated strings.
                        </p>
                        <h3>2. Multi-line strings</h3>
						<p>
                            In `src/04-template-strings/02-multiline-strings.js´, remove all string 
                            concatenations and '\n' characters, and use a multi-line string with embedded 
                            expressions instead.
                        </p>
					</section>
				</section>

				<section>
					<section>
						<h1>Maps and Sets</h1>
						<p>
							New data structures
                        </p>
					</section>
					<section>
                        <h2>Traditional key-value pairs</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
var capitals = {
    'Norway': 'Oslo',
    'Sweden': 'Stockholm'
};
capitals['Denmark'] = 'Copenhagen';

console.log(capitals['Sweden']); 
// 'Stockholm'
							</code>
						</pre>
					</section>
					<section>
                        <h2>Some problems</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
// Iteration is a bit awkward
Object.keys(capitals).map(key => {
    console.log('The capital of ' + key + ' is ' + capitals[key]);
});

// The easiest way to get the size is
var size = Object.keys(capitals).length;

// Keys can only be represented as strings
capitals[1] = 'London';    // 1 is converted to '1'
capitals[true] = 'Berlin'; // true is converted to 'true'
							</code>
						</pre>
					</section>
					<section>
                        <h2>Introducing Map</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
// Initialize the map
var map = new Map();

// Add entry with key 'Norway' and value 'Oslo'
map.set('Norway', 'Oslo');

// Keys can be any data type, object, or even a function
var keyString = "a string",
    keyObj = {},
    keyFunc = function () {};

map.set(keyString, 'value');
map.set(keyObj, 'value');
map.set(keyFunc, 'value');
							</code>
						</pre>
					</section>
					<section>
                        <h2>Iteration and size</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
// Iteration is a bit cleaner
for (let [country, capital] of capitals) {
    console.log('The capital of ' + country + ' is ' + capital);
}

// Getting the size is easy
var size = capitals.size;
							</code>
						</pre>
					</section>
					<section>
                        <h2>Signs that you should be using Map instead of object</h2>
                        <ul>
                            <li>Keys are not known until run time</li>
                            <li>You frequently need to add/remove key-value pairs</li>
                            <li>You need to use keys that are not strings</li>
                            <li>You want to iterate the collection</li>
                        </ul>
					</section>
					<section>
                        <h2>Set introduction</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
// Initialize the set
var set = new Set();

// Add value
set.add('Norway');

// No duplicate values
set.add('Norway'); // has no effect

// Values can be any data type, object, or a function
var obj = {},
    func = function () {};

set.add(obj);
set.add(func);
							</code>
						</pre>
					</section>
					<section>
                        <h2>Set operations</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
// Simple iteration
for (let value of set) {
    console.log(value);
}

// Get size
var size = set.size;

// Check if value exists
var exists = set.has('Norway');

// Delete
set.delete('Norway');
							</code>
						</pre>
					</section>
					<section>
                        <h2>WeakMap</h2>
                        <ul>
                            <li>Similar to Map, but keys are weakly referenced</li>
                            <li>Allows keys to be garbage collected</li>
                            <li>Only objects can be used as keys</li>
                            <li>Not possible to iterate, list keys, or get size</li>
                        </ul>
					</section>
					<section>
                        <h2>WeakMap usage</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
let map = new WeakMap();

let apple = { id: 1, name: 'Apple' };
map.set(apple, 3);
map.get(apple); // 3

// Will not be kept in the map, as no one else is holding a 
// reference to the key
map.set({ id: 2, name: 'Orange' }, 5); 

// Will be held in the map until the element with id 'example' 
// is removed from DOM
map.set(document.getElementById('example'), { clickCount: 4 });
							</code>
						</pre>
					</section>
					<section>
                        <h2>WeakSet</h2>
                        <ul>
                            <li>Similar to Set, but values are weakly referenced</li>
                            <li>Allows values to be garbage collected</li>
                            <li>Only objects can be used as keys</li>
                            <li>Not possible to iterate, list values, or get size</li>
                        </ul>
					</section>
					<section>
                        <h2>Example use case for WeakSet</h2>
						<pre>
							<code class="hjls" data-trim contenteditable>
// Simple tagging of DOM elements that have been touched/edited.
// When elements are removed from DOM, the garbage collector
// will automatically remove them from the Set.

var touchedElements = new WeakSet();

function addTouched(domElement) {
    touchedElements.add(domElement);
}

function hasBeenTouched(domElement) {
    return touchedElements.has(domElement);
}
							</code>
						</pre>
					</section>
					<section>
                        <h2>Code tasks</h2>
                        <h3>1. Map</h3>
						<p>
                            In `src/07-maps-and-sets/01-map.js´, rewrite carMap to be a Map, and modify 
                            the functions so that they work with the Map data structure.
                        </p>
                        <h3>2. Set</h3>
						<p>
                            In `src/07-maps-and-sets/02-set.js´, change getUniqueActors() to use a 
                            Set in order to return a unique array of actors.
                        </p>
					</section>
                </sections>

				<section>
					<h2>Slides</h2>
					<p>
						Not a coder? Not a problem. There's a fully-featured visual editor for authoring these, try it out at <a href="http://slides.com" target="_blank">http://slides.com</a>.
					</p>
				</section>

				<section>
					<h2>Point of View</h2>
					<p>
						Press <strong>ESC</strong> to enter the slide overview.
					</p>
					<p>
						Hold down alt and click on any element to zoom in on it using <a href="http://lab.hakim.se/zoom-js">zoom.js</a>. Alt + click anywhere to zoom back out.
					</p>
				</section>

				<section>
					<h2>Touch Optimized</h2>
					<p>
						Presentations look great on touch devices, like mobile phones and tablets. Simply swipe through your slides.
					</p>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Markdown support

						Write content using inline or external Markdown.
						Instructions and more info available in the [readme](https://github.com/hakimel/reveal.js#markdown).

						```
						<section data-markdown>
						  ## Markdown support

						  Write content using inline or external Markdown.
						  Instructions and more info available in the [readme](https://github.com/hakimel/reveal.js#markdown).
						</section>
						```
					</script>
				</section>

				<section>
					<section id="fragments">
						<h2>Fragments</h2>
						<p>Hit the next arrow...</p>
						<p class="fragment">... to step through ...</p>
						<p><span class="fragment">... a</span> <span class="fragment">fragmented</span> <span class="fragment">slide.</span></p>

						<aside class="notes">
							This slide has fragments which are also stepped through in the notes window.
						</aside>
					</section>
					<section>
						<h2>Fragment Styles</h2>
						<p>There's different types of fragments, like:</p>
						<p class="fragment grow">grow</p>
						<p class="fragment shrink">shrink</p>
						<p class="fragment fade-out">fade-out</p>
						<p class="fragment current-visible">current-visible</p>
						<p class="fragment highlight-red">highlight-red</p>
						<p class="fragment highlight-blue">highlight-blue</p>
					</section>
				</section>

				<section id="transitions">
					<h2>Transition Styles</h2>
					<p>
						You can select from different transitions, like: <br>
						<a href="?transition=none#/transitions">None</a> -
						<a href="?transition=fade#/transitions">Fade</a> -
						<a href="?transition=slide#/transitions">Slide</a> -
						<a href="?transition=convex#/transitions">Convex</a> -
						<a href="?transition=concave#/transitions">Concave</a> -
						<a href="?transition=zoom#/transitions">Zoom</a>
					</p>
				</section>

				<section id="themes">
					<h2>Themes</h2>
					<p>
						reveal.js comes with a few themes built in: <br>
						<!-- Hacks to swap themes after the page has loaded. Not flexible and only intended for the reveal.js demo deck. -->
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/black.css'); return false;">Black (default)</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/white.css'); return false;">White</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/league.css'); return false;">League</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/sky.css'); return false;">Sky</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/beige.css'); return false;">Beige</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/simple.css'); return false;">Simple</a> <br>
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/serif.css'); return false;">Serif</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/blood.css'); return false;">Blood</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/night.css'); return false;">Night</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/moon.css'); return false;">Moon</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/solarized.css'); return false;">Solarized</a>
					</p>
				</section>

				<section>
					<section data-background="#dddddd">
						<h2>Slide Backgrounds</h2>
						<p>
							Set <code>data-background="#dddddd"</code> on a slide to change the background color. All CSS color formats are supported.
						</p>
						<a href="#" class="navigate-down">
							<img width="178" height="238" data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>
					</section>
					<section data-background="https://s3.amazonaws.com/hakim-static/reveal-js/image-placeholder.png">
						<h2>Image Backgrounds</h2>
						<pre><code class="hljs">&lt;section data-background="image.png"&gt;</code></pre>
					</section>
					<section data-background="https://s3.amazonaws.com/hakim-static/reveal-js/image-placeholder.png" data-background-repeat="repeat" data-background-size="100px">
						<h2>Tiled Backgrounds</h2>
						<pre><code class="hljs" style="word-wrap: break-word;">&lt;section data-background="image.png" data-background-repeat="repeat" data-background-size="100px"&gt;</code></pre>
					</section>
					<section data-background-video="https://s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.mp4,https://s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.webm" data-background-color="#000000">
						<div style="background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 20px;">
							<h2>Video Backgrounds</h2>
							<pre><code class="hljs" style="word-wrap: break-word;">&lt;section data-background-video="video.mp4,video.webm"&gt;</code></pre>
						</div>
					</section>
					<section data-background="http://i.giphy.com/90F8aUepslB84.gif">
						<h2>... and GIFs!</h2>
					</section>
				</section>

				<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
					<h2>Background Transitions</h2>
					<p>
						Different background transitions are available via the backgroundTransition option. This one's called "zoom".
					</p>
					<pre><code class="hljs">Reveal.configure({ backgroundTransition: 'zoom' })</code></pre>
				</section>

				<section data-transition="slide" data-background="#b5533c" data-background-transition="zoom">
					<h2>Background Transitions</h2>
					<p>
						You can override background transitions per-slide.
					</p>
					<pre><code class="hljs" style="word-wrap: break-word;">&lt;section data-background-transition="zoom"&gt;</code></pre>
				</section>

				<section>
					<h2>Pretty Code</h2>
					<pre><code class="hljs" data-trim contenteditable>
function linkify( selector ) {
  if( supports3DTransforms ) {

    var nodes = document.querySelectorAll( selector );

    for( var i = 0, len = nodes.length; i &lt; len; i++ ) {
      var node = nodes[i];

      if( !node.className ) {
        node.className += ' roll';
      }
    }
  }
}
					</code></pre>
					<p>Code syntax highlighting courtesy of <a href="http://softwaremaniacs.org/soft/highlight/en/description/">highlight.js</a>.</p>
				</section>

				<section>
					<h2>Marvelous List</h2>
					<ul>
						<li>No order here</li>
						<li>Or here</li>
						<li>Or here</li>
						<li>Or here</li>
					</ul>
				</section>

				<section>
					<h2>Fantastic Ordered List</h2>
					<ol>
						<li>One is smaller than...</li>
						<li>Two is smaller than...</li>
						<li>Three!</li>
					</ol>
				</section>

				<section>
					<h2>Tabular Tables</h2>
					<table>
						<thead>
							<tr>
								<th>Item</th>
								<th>Value</th>
								<th>Quantity</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Apples</td>
								<td>$1</td>
								<td>7</td>
							</tr>
							<tr>
								<td>Lemonade</td>
								<td>$2</td>
								<td>18</td>
							</tr>
							<tr>
								<td>Bread</td>
								<td>$3</td>
								<td>2</td>
							</tr>
						</tbody>
					</table>
				</section>

				<section>
					<h2>Clever Quotes</h2>
					<p>
						These guys come in two forms, inline: <q cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
						&ldquo;The nice thing about standards is that there are so many to choose from&rdquo;</q> and block:
					</p>
					<blockquote cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
						&ldquo;For years there has been a theory that millions of monkeys typing at random on millions of typewriters would
						reproduce the entire works of Shakespeare. The Internet has proven this theory to be untrue.&rdquo;
					</blockquote>
				</section>

				<section>
					<h2>Intergalactic Interconnections</h2>
					<p>
						You can link between slides internally,
						<a href="#/2/3">like this</a>.
					</p>
				</section>

				<section>
					<h2>Speaker View</h2>
					<p>There's a <a href="https://github.com/hakimel/reveal.js#speaker-notes">speaker view</a>. It includes a timer, preview of the upcoming slide as well as your speaker notes.</p>
					<p>Press the <em>S</em> key to try it out.</p>

					<aside class="notes">
						Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
					</aside>
				</section>

				<section>
					<h2>Export to PDF</h2>
					<p>Presentations can be <a href="https://github.com/hakimel/reveal.js#pdf-export">exported to PDF</a>, here's an example:</p>
					<iframe src="https://www.slideshare.net/slideshow/embed_code/42840540" width="445" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:3px solid #666; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>
				</section>

				<section>
					<h2>Global State</h2>
					<p>
						Set <code>data-state="something"</code> on a slide and <code>"something"</code>
						will be added as a class to the document element when the slide is open. This lets you
						apply broader style changes, like switching the page background.
					</p>
				</section>

				<section data-state="customevent">
					<h2>State Events</h2>
					<p>
						Additionally custom events can be triggered on a per slide basis by binding to the <code>data-state</code> name.
					</p>
					<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
Reveal.addEventListener( 'customevent', function() {
	console.log( '"customevent" has fired' );
} );
					</code></pre>
				</section>

				<section>
					<h2>Take a Moment</h2>
					<p>
						Press B or . on your keyboard to pause the presentation. This is helpful when you're on stage and want to take distracting slides off the screen.
					</p>
				</section>

				<section>
					<h2>Much more</h2>
					<ul>
						<li>Right-to-left support</li>
						<li><a href="https://github.com/hakimel/reveal.js#api">Extensive JavaScript API</a></li>
						<li><a href="https://github.com/hakimel/reveal.js#auto-sliding">Auto-progression</a></li>
						<li><a href="https://github.com/hakimel/reveal.js#parallax-background">Parallax backgrounds</a></li>
						<li><a href="https://github.com/hakimel/reveal.js#keyboard-bindings">Custom keyboard bindings</a></li>
					</ul>
				</section>

				<section style="text-align: left;">
					<h1>THE END</h1>
					<p>
						- <a href="http://slides.com">Try the online editor</a> <br>
						- <a href="https://github.com/hakimel/reveal.js">Source code &amp; documentation</a>
					</p>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
